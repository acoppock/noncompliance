{
    "contents" : "#' @export\n#' @param Y The (unquoted) dependent variable\n#' @param D_1 The (unquoted) variable indicating first-round treatment receipt. Must be numeric and take values between 0 and 1.\n#' @param D_2 The (unquoted) variable indicating second-round treatment receipt. Must be numeric or missing. Units that are in the second-round assignment must have numeric values that are 0 or 1. All others will be considered as not part of the second-round experiment.\n#' @param Z_1 The (unquoted) variable indicating first-round treatment assignment. Must be numeric and take values between 0 and 1.\n#' @param Z_2 The (unquoted) variable indicating second-round treatment assignment. Must be numeric or missing. Units that are in the second-round assignment must have numeric values that are 0 or 1. All others will be considered as not part of the second-round experiment.\n#' @param covariates A formula of the form ~ X1 + X2, where X1 and X2 are pre-treatment covariates\n#' @param pr_Z2 a numeric scalar, indicating the probability of assignment in the second round. If not, provided, will be estimated from the data.\n#' @param data a dataframe. If there is missingness in Y or covariates, listwise deletion will be employed.\nestimate_cace_DS <-\n  function(Y, D_1, D_2, Z_1, Z_2, covariates = NULL, pr_Z2 = NULL, data){\n\n    Y <-  eval(substitute(Y), data)\n    if(!is.numeric(Y)){stop(\"Y must be numeric.\")}\n    D_1 <- eval(substitute(D_1), data)\n    if(!all(D_1 %in% c(0, 1))){stop(\"D_1 must be a numeric variable whose values are 0 or 1.\")}\n    D_2 <- eval(substitute(D_2), data)\n    if(!is.numeric(D_2)){stop(\"D_2 must be numeric.\")}\n    Z_1 <- eval(substitute(Z_1), data)\n    if(!all(Z_1 %in% c(0, 1))){stop(\"Z_1 must be a numeric variable whose values are 0 or 1.\")}\n    Z_2 <- eval(substitute(Z_2), data)\n    if(!is.numeric(D_2)){stop(\"D_2 must be numeric.\")}\n\n    Z_2[!Z_2 %in% c(0, 1)] <- NA\n\n    if(!is.null(covariates)){\n      X <- model.frame(covariates, data, na.action = NULL)\n      not_missing <- !is.na(Y) & complete.cases(X)\n      df <- data.frame(Y, D_1, D_2, Z_1, Z_2, X)\n      df <- subset(df, not_missing)\n    }else{\n      not_missing <- !is.na(Y)\n      df <- data.frame(Y, D_1, D_2, Z_1, Z_2)\n      df <- subset(df, not_missing)\n    }\n\n    df <- within(df,{\n      D <- (D_1==1) + (D_2==1)\n    })\n\n    # Obtain formulae\n\n    if(is.null(covariates)){\n      pr_1c_formula <- formula(D_1 ~ Z_1)\n      pr_2c_formula <- formula(D_2 ~ Z_2)\n      ITT1_formula <- formula(Y ~ Z_1)\n      ITT2_formula <- formula(Y ~ Z_2)\n    }else{\n      pr_1c_formula <- formula(paste0(\"D_1 ~ Z_1 +\", as.character(covariates)[2]))\n      pr_2c_formula <- formula(paste0(\"D_2 ~ Z_2 +\", as.character(covariates)[2]))\n      ITT1_formula <- formula(paste0(\"Y ~ Z_1 +\", as.character(covariates)[2]))\n      ITT2_formula <- formula(paste0(\"Y ~ Z_2 +\", as.character(covariates)[2]))\n    }\n\n    estimates <- DS_estimator(pr_1c_formula = pr_1c_formula,\n                               pr_2c_formula = pr_2c_formula,\n                               ITT1_formula = ITT1_formula,\n                               ITT2_formula = ITT2_formula,\n                               pr_Z2 = pr_Z2, df=df)\n    return_object <- list(estimates = estimates,\n                       data = df,\n                       pr_1c_formula = pr_1c_formula,\n                       pr_2c_formula = pr_2c_formula,\n                       ITT1_formula = ITT1_formula,\n                       ITT2_formula = ITT2_formula,\n                       pr_Z2 = pr_Z2)\n    class(return_object) <- \"dsnc\"\n    return(return_object)\n  }\n\n#' @export\nprint.dsnc <- function(object, ...){\n  coef_matrix <- cbind(object$estimates)\n  colnames(coef_matrix) <- c(\"Estimate\")\n  rownames(coef_matrix) <- c(\"1CACE\", \"2CACE\", \"CACE\")\n  print(coef_matrix)\n}\n\n#' @param bootstrap logical, FALSE by default. Should standard errors and 95% confidence intervals be obtained via the nonparametric bootstrap?\n#' @param sims If bootstrap = TRUE, the number of bootstrap simulations calculated. By default, sims = 500.\n#' @export\nsummary.dsnc <- function(object, bootstrap=FALSE, sims = 500,...){\n  if(bootstrap){\n    bootstrapped_estimates <- sapply(X = 1:sims,\n                                     FUN = x <- function(i){\n                                       DS_estimator(pr_1c_formula = object$pr_1c_formula,\n                                                     pr_2c_formula = object$pr_2c_formula,\n                                                     ITT1_formula = object$ITT1_formula,\n                                                     ITT2_formula = object$ITT2_formula,\n                                                     pr_Z2 = object$pr_Z2, df=object$data[sample(1:nrow(object$data),\n                                                                                                 nrow(object$data),\n                                                                                                 replace = TRUE),])\n                                     })\n    ses_vec <- apply(bootstrapped_estimates, 1, sd)\n    cis <- apply(bootstrapped_estimates, 1, quantile, probs=c(0.025, 0.975))\n\n    coef_matrix <- cbind(object$estimates, ses_vec, t(cis))\n\n    colnames(coef_matrix) <- c(\"Estimate\", \"Std. Error\", \"CI Lower\", \"CI Upper\")\n    rownames(coef_matrix) <- c(\"1CACE\", \"2CACE\", \"CACE\")\n  }else{\n    coef_matrix <- cbind(object$estimates)\n    colnames(coef_matrix) <- c(\"Estimate\")\n    rownames(coef_matrix) <- c(\"1CACE\", \"2CACE\", \"CACE\")\n  }\n\n  pr_1c_hat <-lm(object$pr_1c_formula, data = object$data)$coefficients[2]\n  pr_firstroundnoncompliers <- with(object$data, mean(D_1[Z_1==1]==0))\n  pr_2c_hat <- lm(object$pr_2c_formula, data = subset(object$data, !is.na(Z_2)))$coefficients[2] * pr_firstroundnoncompliers\n\n\n  return_object <- list(coef_matrix = coef_matrix,\n                        pr_1c_hat = pr_1c_hat,\n                        pr_2c_hat = pr_2c_hat)\n  class(return_object) <- \"summary.dsnc\"\n  return(return_object)\n}\n\n#' @export\nprint.summary.dsnc <- function(object, ...){\n\n  cat(\"\\n Double Sampling for Noncompliance: \\n\")\n\n  print(object$coef_matrix)\n\n  cat(paste0(\"\\n Estimate of proportion of first-round compliers: \", round(object$pr_1c_hat, 3)))\n  cat(paste0(\"\\n Estimate of proportion of second-round compliers: \", round(object$pr_2c_hat, 3)))\n\n}\n\n#' @export\nDS_estimator <- function(pr_1c_formula, pr_2c_formula, ITT1_formula, ITT2_formula,pr_Z2, df){\n\n  # Obtain building blocks\n  pr_1c_hat <-lm(pr_1c_formula, data = df)$coefficients[2]\n  pr_firstroundnoncompliers <- with(df, mean(D_1[Z_1==1]==0))\n  pr_2c_hat <- lm(pr_2c_formula, data = subset(df, !is.na(Z_2)))$coefficients[2] * pr_firstroundnoncompliers\n\n  ITT1_hat <- lm(ITT1_formula, data=df)$coefficients[2]\n  ITT2_hat <- lm(ITT2_formula, data=subset(df,!is.na(Z_2)))$coefficients[2]\n\n  # Obtain Estimates\n  cace2_hat <- ITT2_hat/ (pr_2c_hat/pr_firstroundnoncompliers)\n  cace1_hat <- (ITT1_hat - pr_2c_hat * pr_Z2 *cace2_hat)/pr_1c_hat\n  CACE_hat <- (pr_1c_hat*cace1_hat + pr_2c_hat*cace2_hat)/(pr_1c_hat + pr_2c_hat)\n\n  return(c(cace1_hat=cace1_hat,\n           cace2_hat=cace2_hat,\n           CACE_hat = CACE_hat))\n}\n\n# CACE Estimate\n#' @export\nestimate_cace <- function(Y, D, Z, covariates = NULL, data){\n\n  require(AER)\n  Y <-  eval(substitute(Y), data)\n  if(!is.numeric(Y)){stop(\"Y must be numeric.\")}\n  D <- eval(substitute(D), data)\n  if(!all(D %in% c(0, 1))){stop(\"D must be a numeric variable whose values are 0 or 1.\")}\n  Z <- eval(substitute(Z), data)\n  if(!all(Z %in% c(0, 1))){stop(\"Z must be a numeric variable whose values are 0 or 1.\")}\n\n  if(!is.null(covariates)){\n    X <- model.frame(covariates, data, na.action = NULL)\n    not_missing <- !is.na(Y) & complete.cases(X)\n    df <- data.frame(Y, D, Z, X)\n    df <- subset(df, not_missing)\n  }else{\n    not_missing <- !is.na(Y)\n    df <- data.frame(Y, D, Z)\n    df <- subset(df, not_missing)\n  }\n\n  if(is.null(covariates)){\n    CACE_formula <- \"Y ~ D | Z\"\n  }else{\n    CACE_formula <- paste0(\"Y ~ D +\",\n                           as.character(covariates)[2],\n                           \" | Z + \",\n                           as.character(covariates)[2])\n  }\n\n  fit <- ivreg(CACE_formula, data = df)\n\n  return_object <- list(fit = fit,\n                        CACE_formula = CACE_formula,\n                        df = df)\n  class(return_object) <- \"cace\"\n return(return_object)\n}\n\n#' @export\nprint.cace <- function(object){\n  print(object$fit)\n}\n\n#' @export\nsummary.cace <- function(object){\n  print(summary(object$fit))\n}\n\n# Estimate the CACE from a Three-Group Design\n#' @param Y The (unquoted) dependent variable. Must be numeric and take values that are 0 or 1.\n#' @param D The (unquoted) variable indicating treatment receipt. Must be numeric and take values that are 0 or 1. Should equal 1 if contacted under placebo or treatment.\n#' @param Z The (unquoted) variable indicating treatment assignment. Must be numeric and be equal to 0 (baseline), 1 (treatment), or 2 (placebo).\n#' @export\nestimate_3g <- function(Y, D, Z, data){\n\n  Y <-  eval(substitute(Y), data)\n  if(!all(Y %in% c(0, 1))){stop(\"Y must be a numeric variable whose values are 0 or 1.\")}\n  D <- eval(substitute(D), data)\n  if(!all(D %in% c(0, 1))){stop(\"D must be a numeric variable whose values are 0 or 1.\")}\n  Z <- eval(substitute(Z), data)\n  if(!all(Z %in% c(0, 1, 2))){stop(\"Z must be a numeric variable whose values are 0, 1, or 2.\")}\n\n  v_b = sum(Y[Z==0]==1)\n  a_b = sum(Y[Z==0]==0)\n\n  v_t_c = sum(Y[Z==1 & D==1]==1)\n  a_t_c = sum(Y[Z==1 & D==1]==0)\n\n  v_t_u = sum(Y[Z==1 & D==0]==1)\n  a_t_u = sum(Y[Z==1 & D==0]==0)\n\n  v_p_c = sum(Y[Z==2 & D==1]==1)\n  a_p_c = sum(Y[Z==2 & D==1]==0)\n\n  v_p_u = sum(Y[Z==2 & D==0]==1)\n  a_p_u = sum(Y[Z==2 & D==0]==0)\n\n  # Estimate Three Group\n  optim.out <- optim(par = c(.2,.2,.2,0), ThreeG, method = \"Nelder-Mead\",\n                     control = list(fnscale = -1, reltol = .Machine$double.eps,\n                                    trace = 0, maxit = 10000), hessian = T,\n                     v_b = v_b,\n                     a_b = a_b,\n                     v_t_c = v_t_c,\n                     a_t_c = a_t_c,\n                     v_t_u = v_t_u,\n                     a_t_u = a_t_u,\n                     v_p_c = v_p_c,\n                     a_p_c = a_p_c,\n                     v_p_u = v_p_u,\n                     a_p_u = a_p_u )\n  res1 <- cbind(optim.out$par, sqrt(diag(solve(-optim.out$hessian))))\n  rownames(res1) <- c(\"alpha (D rate)\", \"p_r\", \"p_nr\", \"tau (treatment effect)\")\n\n  # Baseline & Treatment Only\n\n  optim.out <- optim(par = c(.2,.2,.2,0), ThreeGBT, method = \"Nelder-Mead\",\n                     control = list(fnscale = -1, reltol = .Machine$double.eps,\n                                    trace = 0, maxit = 10000), hessian = T,\n                     v_b = v_b,\n                     a_b = a_b,\n                     v_t_c = v_t_c,\n                     a_t_c = a_t_c,\n                     v_t_u = v_t_u,\n                     a_t_u = a_t_u )\n\n  #stopifnot(optim.out$convergence == 0)\n  warning(optim.out$convergence != 0)\n\n  res2 <- cbind(optim.out$par, sqrt(diag(solve(-optim.out$hessian))))\n  rownames(res2) <- c(\"alpha (D rate)\", \"p_r\", \"p_nr\", \"tau (treatment effect)\")\n\n  # Placebo & Treatment Only\n\n  optim.out <- optim(par = c(.2,.2,.2,0), ThreeGPT, method = \"Nelder-Mead\",\n                     control = list(fnscale = -1, reltol = .Machine$double.eps,\n                                    trace = 0, maxit = 10000), hessian = T,\n                     v_t_c = v_t_c,\n                     a_t_c = a_t_c,\n                     v_t_u = v_t_u,\n                     a_t_u = a_t_u,\n                     v_p_c = v_p_c,\n                     a_p_c = a_p_c,\n                     v_p_u = v_p_u,\n                     a_p_u = a_p_u )\n\n  #stopifnot(optim.out$convergence == 0)\n  warning(optim.out$convergence != 0)\n\n  # Estimates and standard errors\n  res3 <- cbind(optim.out$par, sqrt(diag(solve(-optim.out$hessian))))\n\n\n  ##########################\n  # X^2 GOODNESS-OF-FIT TEST\n  ##########################\n  p_r <- res1[2,1]\n  p_nr <- res1[3,1]\n  alpha <- res1[1,1]\n  tau <- res1[4,1]\n\n  pred_v_b <- (v_b+a_b) * (     alpha * (p_r-tau) + (1-alpha) * p_nr )\n  pred_a_b <- (v_b+a_b) * (1- ( alpha * (p_r-tau) + (1-alpha) * p_nr ))\n\n  pred_v_t_c <- (v_t_c+a_t_c+v_t_u+a_t_u)  * ( alpha * (   p_r) )\n  pred_a_t_c <-  (v_t_c+a_t_c+v_t_u+a_t_u) * ( alpha * (1-(p_r)) )\n\n  pred_v_t_u <-  (v_t_c+a_t_c+v_t_u+a_t_u) * ( (1 -  alpha) * (    p_nr) )\n  pred_a_t_u <-  (v_t_c+a_t_c+v_t_u+a_t_u) * ( (1 -  alpha) * (1 - p_nr) )\n\n  pred_v_p_c <-  (v_p_c+a_p_c+v_p_u+a_p_u) * ( alpha * (   p_r-tau) )\n  pred_a_p_c <-  (v_p_c+a_p_c+v_p_u+a_p_u) * ( alpha * (1-(p_r-tau)) )\n\n  pred_v_p_u <- (v_p_c+a_p_c+v_p_u+a_p_u) * ( (1 -  alpha) * (    p_nr) )\n  pred_a_p_u <- (v_p_c+a_p_c+v_p_u+a_p_u) * ( (1 -  alpha) * (1 - p_nr) )\n\n\n  expected <- c(  pred_v_b, pred_a_b, pred_v_t_c, pred_a_t_c, pred_v_t_u, pred_a_t_u, pred_v_p_c,\n                  pred_a_p_c, pred_v_p_u, pred_a_p_u)\n\n  observed <- c(  v_b, a_b, v_t_c, a_t_c, v_t_u, a_t_u, v_p_c, a_p_c, v_p_u, a_p_u)\n\n\n  # observed vs. expected freqencies\n\n  chi_sq_stat <- sum((observed - expected)^2 / expected)\n  chi_sq_p_value <- pchisq(q = chi_sq_stat, df = 3, lower.tail = F)\n\n  # Reporting\n  rownames(res1) <- rownames(res2) <- rownames(res3) <-\n    c(\"alpha (D rate)\", \"p_r\", \"p_nr\", \"tau (treatment effect)\")\n\n  res1 <- cbind(res1, res1[,1]/res1[,2], 2*pnorm(abs(res1[,1]/res1[,2]),lower.tail = FALSE))\n  res2 <- cbind(res2, res2[,1]/res2[,2], 2*pnorm(abs(res2[,1]/res2[,2]),lower.tail = FALSE))\n  res3 <- cbind(res3, res3[,1]/res3[,2], 2*pnorm(abs(res3[,1]/res3[,2]),lower.tail = FALSE))\n\n  colnames(res1) <- colnames(res2) <- colnames(res3) <-\n    c(\"Estimate\", \"Std. Error\", \"t value\", \"Pr(>|t|)\")\n\n  return(list(Three_Group=round(res1, digits=4), Baseline_Treatment=round(res2, digits=4), Placebo_Treatment=round(res3, digits=4), Goodness_of_fit=c(chi_sq_stat=chi_sq_stat,\n                                                                                                                                                      chi_sq_p_value=chi_sq_p_value)))\n\n}\n\n\n\n",
    "created" : 1444532361955.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1019003874",
    "id" : "470803BF",
    "lastKnownWriteTime" : 1444536635,
    "path" : "~/Documents/noncompliance/R/estimators.R",
    "project_path" : "R/estimators.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}